Btrfs Heatmap - Scripting
=========================

When doing something more sophisticated than just creating a picture of a
complete filesystem or a single block group, it's better to do it from python
and use the btrfs library to find the objects that we want to display.

The heatmap code is not a full-blown library, but that doesn't prevent us from
importing the heatmap.py from another script in the same directory and then
using functions from it.

First, we'll have a look at some interesting fuctions inside `heatmap.py`,
after which I'll show some examples of how to use them.

## 1. Internal heatmap.py functions

### 1.1 Working with devices, dev extent level picture

```python
walk_dev_extents(fs, devices=None, order=None, size=None,
                 default_granularity=33554432, verbose=0,
                 min_brightness=None, curve=None)
```

 * `fs` is a btrfs.FileSystem object.
 * `devices` is a list of one or more device objects, or `None` to
   automatically use all of them.
 * `order` defines the hilbert curve order. Most of the time it's best to let
   it be determined automatically. A higher number will result in a more
   detailed picture, with less bytes per pixel.
 * `size` defines the size of the output image. By default, this is 10, which
   means a picture with a height and width of 1024 (2^10). If the size argument
   is higher than the curve order, pixels are simply duplicated when writing
   out the png picture.
 * `default_granularity` defines the amount of bytes that should be mapped
   (approximately) on a single pixel in the output to determine the hilbert
   curve order to use. By default, this is 32MiB.
 * A higher number for `verbose` makes the output more verbose (like `-vvv` on
   the command line of `heatmap.py` would be `verbose=3`).
 * `min_brightness` (0 <= `min_brightness` <= 1, default 0.1) sets the minimal
   brightness of pixels that are part of allocated space, to be able to
   distinguish them from unallocated space when usage is really low.
 * `curve` is either 'hilbert' (the default), 'snake', or 'linear'

### 1.2 Working with block groups, extent level picture

```python
walk_extents(fs, block_groups, order=None, size=None,
             default_granularity=None, verbose=0, curve=None)
```

 * `block_groups` is a list of one or multiple block group objects.
 * For block group internals, `default_granularity` defaults to the sector size
   of the filesystem, which is often 4096 bytes.
 * for other options, see above

### 1.3 A helper for generating file names

```python
generate_png_file_name(output=None, parts=None)
```

 * `parts` is a list of filename parts that will be concatenated, after which a
   timestamp is also added.  e.g. `parts=['foo', 'bar']` results in
   `foo_bar_at_1482095269.png`
 * `output` can be a filename, in which case the function just returns that
   filename again
 * `output` can be a directory, in which case the function will return a path
   to an autogenerated filename using parts in that directory

## 2. Examples

### 2.1 Full filesystem image

The following is the equivalent of doing `heatmap.py --size 8 -o full-fs.png /`:

```python
#!/usr/bin/python
import btrfs
import heatmap
fs = btrfs.FileSystem('/')
heatmap.walk_dev_extents(fs, size=8).write_png('full-fs.png')
```

output:
```
scope device 1
grid order 5 size 8 height 32 width 32 total_bytes 21474836480 bytes_per_pixel 20971520.0
pngfile full-fs.png
```

20 GiB file system    |
:-------------------------:|
![Full FS](scripting/full-fs.png) |

### 2.2 The four newest DATA block groups together

```python
#!/usr/bin/python
import btrfs
import heatmap
fs = btrfs.FileSystem('/')
four_newest_bg = [fs.block_group(chunk.vaddr, chunk.length)
                  for chunk in fs.chunks()
                  if chunk.type & btrfs.BLOCK_GROUP_DATA][-4:]
grid = heatmap.walk_extents(fs, four_newest_bg)
parts = ['fsid', fs.fsid, 'startat', four_newest_bg[0].vaddr]
png_filename = heatmap.generate_png_file_name('/output/directory/', parts=parts)
grid.write_png(png_filename)
```

output:
```
scope block_group 154696417280 155770159104 156843900928 157917642752
grid order 8 size 8 height 256 width 256 total_bytes 4294967296 bytes_per_pixel 65536.0
pngfile fsid_9881fc30-8f69-4069-a8c8-c057b842b0c4_startat_154696417280_at_1484406586.png
```

This example uses the png file name generator helper which adds a timestamp so
we can easily repeat it to get images which can be put together into a timelapse.

4 newest DATA block groups    |
:-------------------------:|
![Four block groups](scripting/4-highest.png) |

### 2.3 Show usage, separate image per device, more verbose output

The following script generates a separate picture per physical device:

```python
#!/usr/bin/python
import btrfs
import heatmap
fs = btrfs.FileSystem('/mnt/raid0')
for device in fs.devices():
    heatmap.walk_dev_extents(fs, [device], verbose=1).write_png('device_%s.png' % device.devid)
```

output:
```
scope device 1
grid order 5 size 10 height 32 width 32 total_bytes 26843545600 bytes_per_pixel 26214400.0
dev_extent devid 1 paddr 20971520 length 8388608 pend 29360127 type SYSTEM|RAID0 used_pct 0.10
dev_extent devid 1 paddr 29360128 length 1073741824 pend 1103101951 type METADATA|RAID0 used_pct 6.57
dev_extent devid 1 paddr 1103101952 length 1073741824 pend 2176843775 type DATA|RAID0 used_pct 50.51
pngfile device_1.png

scope device 2
grid order 5 size 10 height 32 width 32 total_bytes 26843545600 bytes_per_pixel 26214400.0
dev_extent devid 2 paddr 1048576 length 8388608 pend 9437183 type SYSTEM|RAID0 used_pct 0.10
dev_extent devid 2 paddr 9437184 length 1073741824 pend 1083179007 type METADATA|RAID0 used_pct 6.57
dev_extent devid 2 paddr 1083179008 length 1073741824 pend 2156920831 type DATA|RAID0 used_pct 50.51
pngfile device_2.png
```

### 2.4 Detailed picture of a full filesystem

```python
#!/usr/bin/python

import btrfs
import heatmap

fs = btrfs.FileSystem('/')
bgs = [fs.block_group(chunk.vaddr, chunk.length)
       for chunk in fs.chunks()]
grid = heatmap.walk_extents(fs, bgs, size=9)
parts = ['fsid', fs.fsid, 'all_bg']
png_filename = heatmap.generate_png_file_name(parts=parts)
grid.write_png(png_filename)
```

output:
```
scope block_group 87285563392 87319117824 89466601472 90540343296 90808778752 91077214208
    91345649664 91614085120 91882520576 92150956032 122215727104 123289468928 130000355328
    154696417280 155770159104 156843900928 157917642752
grid order 9 size 9 height 512 width 512 total_bytes 11576279040 bytes_per_pixel 44160.0
pngfile fsid_9881fc30-8f69-4069-a8c8-c057b842b0c4_all_bg_at_1484409171.png
```

Note that the following picture, while being taken of the same filesystem as the 'full fs'
picture in the first example, has a very different ordering. The block groups in the virtual
address space do not have to map to the same order as allocated chunks of disk.

And, because the picture shows all block groups, it does not show any
unallocated raw disk space.

I used size 9 in this example, to get a picture that would fit into this page.
When specifying a higher hilbert curve order (like 11, or maybe even 12), a
very detailed, but very big picture can be made.

All block groups    |
:-------------------------:|
![All block groups](scripting/all-bg.png) |
